name: MatchingServer CI/CD Pipeline

on:
  push:
    branches: [ main, dev ]
    paths:
      - 'MatchingServer/**'
      - '.github/workflows/matching-server-ci-cd.yml'
  # pull_request:
  #   branches: [ main, master, develop ]
  #   paths:
  #     - 'MatchingServer/**'
  workflow_dispatch:
    inputs:
      environment:
        description: '배포 환경 (dev/prod)'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          # - prod

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/matching-server
  WORKING_DIRECTORY: MatchingServer

jobs:
  # 코드 검증 및 빌드 준비
  check:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ${{ env.WORKING_DIRECTORY }}
    outputs:
      vcpkg_changed: ${{ steps.check-changes.outputs.vcpkg_changed }}
      code_changed: ${{ steps.check-changes.outputs.code_changed }}
      
    steps:
      - name: 코드 체크아웃
        uses: actions/checkout@v3
        with:
          fetch-depth: 2
      
      - name: 변경 사항 검사
        id: check-changes
        run: |
          if git diff --name-only HEAD^ HEAD | grep -q 'MatchingServer/vcpkg.json'; then
            echo "vcpkg_changed=true" >> $GITHUB_OUTPUT
          else
            echo "vcpkg_changed=false" >> $GITHUB_OUTPUT
          fi
          
          if git diff --name-only HEAD^ HEAD | grep -q -E 'MatchingServer/.*\.(cpp|h|hpp)$'; then
            echo "code_changed=true" >> $GITHUB_OUTPUT
          else
            echo "code_changed=false" >> $GITHUB_OUTPUT
          fi

  # Docker 이미지 빌드 및 푸시
  build:
    needs: check
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ${{ env.WORKING_DIRECTORY }}
    permissions:
      contents: read
      packages: write
      
    steps:
      - name: 코드 체크아웃
        uses: actions/checkout@v3
      
      - name: 빌드 환경 설정
        run: |
          mkdir -p db_init
          cp db-init.sql db_init/init.sql || true
          
          # 최적화된 Dockerfile 생성
          cat > Dockerfile.optimized << 'EOL'
          # 1단계: vcpkg 빌드 및 의존성 설치
          FROM ubuntu:22.04 AS vcpkg-builder

          # 기본 환경 변수 설정
          ENV DEBIAN_FRONTEND=noninteractive
          ENV TZ=Asia/Seoul

          # vcpkg 빌드에 필요한 최소한의 패키지만 설치
          RUN apt-get update && apt-get install -y \
              build-essential \
              curl \
              zip \
              unzip \
              tar \
              pkg-config \
              git \
              ninja-build \
              cmake \
              && apt-get clean \
              && rm -rf /var/lib/apt/lists/*

          # vcpkg 설치 (소스 코드 없이)
          WORKDIR /vcpkg-build
          RUN git clone https://github.com/microsoft/vcpkg.git . \
              && ./bootstrap-vcpkg.sh

          # vcpkg.json 파일만 복사하여 의존성 설치
          COPY vcpkg.json .
          RUN ./vcpkg install --triplet=x64-linux

          # 2단계: 애플리케이션 빌드
          FROM ubuntu:22.04 AS builder

          # 기본 환경 변수 설정
          ENV DEBIAN_FRONTEND=noninteractive
          ENV TZ=Asia/Seoul

          # 빌드에 필요한 패키지 설치
          RUN apt-get update && apt-get install -y \
              build-essential \
              pkg-config \
              bison \
              flex \
              libssl-dev \
              zlib1g-dev \
              libpq-dev \
              && apt-get clean \
              && rm -rf /var/lib/apt/lists/*

          # 작업 디렉터리 설정
          WORKDIR /app

          # 첫 번째 단계에서 빌드한 vcpkg와 설치된 패키지를 복사
          COPY --from=vcpkg-builder /vcpkg-build /app/vcpkg
          COPY --from=vcpkg-builder /vcpkg-build/vcpkg_installed /app/vcpkg_installed

          # 소스 코드 복사
          COPY . .

          # 빌드
          RUN export LD_LIBRARY_PATH="$PWD/vcpkg_installed/x64-linux/lib:$LD_LIBRARY_PATH" \
              && make

          # 3단계: 실행 환경 설정
          FROM ubuntu:22.04

          ENV TZ=Asia/Seoul

          # 실행에 필요한 최소한의 패키지만 설치
          RUN apt-get update && apt-get install -y \
              libssl-dev \
              libpq-dev \
              ca-certificates \
              && apt-get clean \
              && rm -rf /var/lib/apt/lists/*

          WORKDIR /app

          # 빌드된 바이너리와 필요한 라이브러리만 복사
          COPY --from=builder /app/build/bin/MatchingServer /app/
          COPY --from=builder /app/vcpkg_installed/x64-linux/lib /app/lib
          COPY --from=builder /app/vcpkg_installed/x64-linux/bin /app/bin

          # 라이브러리 경로 설정
          ENV LD_LIBRARY_PATH="/app/lib:${LD_LIBRARY_PATH}"

          # 서버 포트 노출
          EXPOSE 8080

          # 컨테이너 실행 시 서버 시작
          CMD ["./MatchingServer"]
          EOL
      
      - name: Docker 설정
        uses: docker/setup-buildx-action@v2
      
      - name: GitHub Container Registry 로그인
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: 메타데이터 추출
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,format=short
            type=raw,value=latest,enable={{is_default_branch}}
      
      - name: Docker 이미지 빌드 및 푸시
        uses: docker/build-push-action@v3
        with:
          context: ${{ env.WORKING_DIRECTORY }}
          file: ${{ env.WORKING_DIRECTORY }}/Dockerfile.optimized
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1

  # 개발 환경 배포
  deploy-dev:
    needs: build
    if: github.ref == 'refs/heads/develop' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'dev')
    runs-on: ubuntu-latest
    environment: development
    
    steps:
      - name: 코드 체크아웃
        uses: actions/checkout@v3
      
      - name: docker-compose.yml 파일 생성
        run: |
          cat > docker-compose.yml << 'EOL'
          version: '3.8'

          services:
            db:
              image: postgres:14
              container_name: game_db
              restart: always
              environment:
                POSTGRES_USER: admin
                POSTGRES_PASSWORD: admin
                POSTGRES_DB: gamedata
              volumes:
                - postgres_data:/var/lib/postgresql/data
                - ./db_init:/docker-entrypoint-initdb.d
              ports:
                - "5432:5432"
              networks:
                - game_network
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U admin -d gamedata"]
                interval: 10s
                timeout: 5s
                retries: 5

            matching_server:
              image: ghcr.io/${{ env.IMAGE_NAME }}:${{ github.ref_name }}
              container_name: matching_server
              restart: always
              depends_on:
                db:
                  condition: service_healthy
              environment:
                DB_HOST: db
                DB_PORT: 5432
                DB_NAME: gamedata
                DB_USER: admin
                DB_PASSWORD: admin
              ports:
                - "8080:8080"
              networks:
                - game_network
              logging:
                driver: "json-file"
                options:
                  max-size: "10m"
                  max-file: "3"

          networks:
            game_network:
              driver: bridge

          volumes:
            postgres_data:
          EOL
      
      - name: 서버 배포
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.DEV_SERVER_HOST }}
          username: ${{ secrets.DEV_SERVER_USER }}
          key: ${{ secrets.DEV_SSH_PRIVATE_KEY }}
          port: ${{ secrets.DEV_SSH_PORT }}
          script: |
            cd ${{ secrets.DEV_DEPLOY_PATH }}
            mkdir -p db_init
            
            # docker-compose 파일 전송
            cat > docker-compose.yml << 'EOL'
            version: '3.8'

            services:
              db:
                image: postgres:14
                container_name: game_db
                restart: always
                environment:
                  POSTGRES_USER: admin
                  POSTGRES_PASSWORD: admin
                  POSTGRES_DB: gamedata
                volumes:
                  - postgres_data:/var/lib/postgresql/data
                  - ./db_init:/docker-entrypoint-initdb.d
                ports:
                  - "5432:5432"
                networks:
                  - game_network
                healthcheck:
                  test: ["CMD-SHELL", "pg_isready -U admin -d gamedata"]
                  interval: 10s
                  timeout: 5s
                  retries: 5

              matching_server:
                image: ghcr.io/${{ env.IMAGE_NAME }}:${{ github.ref_name }}
                container_name: matching_server
                restart: always
                depends_on:
                  db:
                    condition: service_healthy
                environment:
                  DB_HOST: db
                  DB_PORT: 5432
                  DB_NAME: gamedata
                  DB_USER: admin
                  DB_PASSWORD: admin
                ports:
                  - "8080:8080"
                networks:
                  - game_network
                logging:
                  driver: "json-file"
                  options:
                    max-size: "10m"
                    max-file: "3"

            networks:
              game_network:
                driver: bridge

            volumes:
              postgres_data:
            EOL
            
            # DB 초기화 파일 복사 (원격 서버에 파일 생성)
            cat > db_init/init.sql << 'EOL'
            -- PostgreSQL 유저 생성 (존재하지 않는 경우에만)
            DO
            $$
            BEGIN
               IF NOT EXISTS (
                  SELECT FROM pg_catalog.pg_roles
                  WHERE rolname = 'admin') THEN
                  CREATE USER admin WITH PASSWORD 'admin' SUPERUSER;
               END IF;
            END
            $$;

            -- 테이블 및 데이터 초기화 스크립트
            DROP TABLE IF EXISTS games CASCADE;
            DROP TABLE IF EXISTS room_users CASCADE;
            DROP TABLE IF EXISTS rooms CASCADE;
            DROP TABLE IF EXISTS maps CASCADE;
            DROP TABLE IF EXISTS users CASCADE;

            -- 사용자 테이블
            CREATE TABLE users (
                user_id SERIAL PRIMARY KEY,
                user_name VARCHAR(50) NOT NULL UNIQUE,
                nick_name VARCHAR(16) DEFAULT 'user_' || substring(md5(random()::text), 1, 10),
                password_hash VARCHAR(255) NOT NULL,
                created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
                last_login TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
            );

            -- 맵 테이블
            CREATE TABLE maps (
                map_id SERIAL PRIMARY KEY,
                map_name VARCHAR(50) NOT NULL UNIQUE
            );

            -- 방 테이블
            CREATE TABLE rooms (
                room_id SERIAL PRIMARY KEY,
                room_name VARCHAR(100) NOT NULL,
                host_id INTEGER NOT NULL REFERENCES users(user_id),
                ip_address VARCHAR(45),
                port INTEGER,
                max_players INTEGER NOT NULL DEFAULT 8,
                status VARCHAR(20) NOT NULL DEFAULT 'TERMINATED',
                created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
                CHECK (status IN ('WAITING', 'GAME_IN_PROGRESS', 'TERMINATED'))
            );

            -- 방 참가자 테이블
            CREATE TABLE room_users (
                room_id SERIAL NOT NULL REFERENCES rooms(room_id),
                user_id INTEGER NOT NULL REFERENCES users(user_id),
                joined_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
                PRIMARY KEY (room_id, user_id)
            );

            -- 게임 테이블
            CREATE TABLE games (
                game_id SERIAL PRIMARY KEY,
                room_id SERIAL NOT NULL REFERENCES rooms(room_id),
                map_id INTEGER NOT NULL REFERENCES maps(map_id),
                status VARCHAR(20) NOT NULL DEFAULT 'IN_PROGRESS',
                started_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
                completed_at TIMESTAMP WITH TIME ZONE,
                CHECK (status IN ('IN_PROGRESS', 'COMPLETED'))
            );

            -- 인덱스 생성
            CREATE INDEX idx_users_username ON users(user_name);
            CREATE INDEX idx_users_nickname ON users(nick_name);
            CREATE INDEX idx_rooms_status ON rooms(status);
            CREATE INDEX idx_rooms_created_at ON rooms(created_at);
            CREATE INDEX idx_room_users_user_id ON room_users(user_id);
            CREATE INDEX idx_games_room_id ON games(room_id);
            CREATE INDEX idx_games_status ON games(status);

            -- 권한 부여
            GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO admin;
            GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO admin;

            ALTER DEFAULT PRIVILEGES IN SCHEMA public
            GRANT ALL PRIVILEGES ON TABLES TO admin;

            ALTER DEFAULT PRIVILEGES IN SCHEMA public
            GRANT ALL PRIVILEGES ON SEQUENCES TO admin;

            -- 초기 데이터 삽입
            INSERT INTO users (user_id, user_name, nick_name, password_hash)
            VALUES (0, 'Mirror', 'Manager', 'Mirror');

            INSERT INTO maps (map_name) VALUES ('SSAFY');
            INSERT INTO maps (map_name) VALUES ('Playground');

            DO $$
            DECLARE
                i INTEGER;
            BEGIN
                FOR i IN 0..19 LOOP
                    INSERT INTO rooms (room_name, host_id, ip_address, port)
                    VALUES ('room' || i, 0, '127.0.0.1', 40000 + i);
                END LOOP;
            END $$;
            EOL
            
            # GitHub Container Registry 로그인
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            
            # 배포 실행
            docker-compose down
            docker-compose pull
            docker-compose up -d
            
            # 사용하지 않는 이미지 정리
            docker system prune -af
            
            echo "===== 배포 완료 ====="
            docker-compose ps

  # 프로덕션 환경 배포 (수동 승인)
  # deploy-prod:
  #   needs: build
  #   if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'prod')
  #   runs-on: ubuntu-latest
  #   environment: production
    
  #   steps:
  #     - name: 코드 체크아웃
  #       uses: actions/checkout@v3
      
  #     - name: docker-compose.yml 파일 생성
  #       run: |
  #         cat > docker-compose.yml << 'EOL'
  #         version: '3.8'

  #         services:
  #           db:
  #             image: postgres:14
  #             container_name: game_db
  #             restart: always
  #             environment:
  #               POSTGRES_USER: admin
  #               POSTGRES_PASSWORD: admin
  #               POSTGRES_DB: gamedata
  #             volumes:
  #               - postgres_data:/var/lib/postgresql/data
  #               - ./db_init:/docker-entrypoint-initdb.d
  #             ports:
  #               - "5432:5432"
  #             networks:
  #               - game_network
  #             healthcheck:
  #               test: ["CMD-SHELL", "pg_isready -U admin -d gamedata"]
  #               interval: 10s
  #               timeout: 5s
  #               retries: 5

  #           matching_server:
  #             image: ghcr.io/${{ env.IMAGE_NAME }}:${{ github.ref_name }}
  #             container_name: matching_server
  #             restart: always
  #             depends_on:
  #               db:
  #                 condition: service_healthy
  #             environment:
  #               DB_HOST: db
  #               DB_PORT: 5432
  #               DB_NAME: gamedata
  #               DB_USER: admin
  #               DB_PASSWORD: admin
  #             ports:
  #               - "8080:8080"
  #             networks:
  #               - game_network
  #             logging:
  #               driver: "json-file"
  #               options:
  #                 max-size: "10m"
  #                 max-file: "3"

  #         networks:
  #           game_network:
  #             driver: bridge

  #         volumes:
  #           postgres_data:
  #         EOL
      
  #     - name: 서버 배포
  #       uses: appleboy/ssh-action@master
  #       with:
  #         host: ${{ secrets.PROD_SERVER_HOST }}
  #         username: ${{ secrets.PROD_SERVER_USER }}
  #         key: ${{ secrets.PROD_SSH_PRIVATE_KEY }}
  #         port: ${{ secrets.PROD_SSH_PORT }}
  #         script: |
  #           cd ${{ secrets.PROD_DEPLOY_PATH }}
  #           mkdir -p db_init
            
  #           # docker-compose 파일 전송 (위와 동일, 프로덕션 환경용)
  #           cat > docker-compose.yml << 'EOL'
  #           version: '3.8'

  #           services:
  #             db:
  #               image: postgres:14
  #               container_name: game_db
  #               restart: always
  #               environment:
  #                 POSTGRES_USER: admin
  #                 POSTGRES_PASSWORD: admin
  #                 POSTGRES_DB: gamedata
  #               volumes:
  #                 - postgres_data:/var/lib/postgresql/data
  #                 - ./db_init:/docker-entrypoint-initdb.d
  #               ports:
  #                 - "5432:5432"
  #               networks:
  #                 - game_network
  #               healthcheck:
  #                 test: ["CMD-SHELL", "pg_isready -U admin -d gamedata"]
  #                 interval: 10s
  #                 timeout: 5s
  #                 retries: 5

  #             matching_server:
  #               image: ghcr.io/${{ env.IMAGE_NAME }}:${{ github.ref_name }}
  #               container_name: matching_server
  #               restart: always
  #               depends_on:
  #                 db:
  #                   condition: service_healthy
  #               environment:
  #                 DB_HOST: db
  #                 DB_PORT: 5432
  #                 DB_NAME: gamedata
  #                 DB_USER: admin
  #                 DB_PASSWORD: admin
  #               ports:
  #                 - "8080:8080"
  #               networks:
  #                 - game_network
  #               logging:
  #                 driver: "json-file"
  #                 options:
  #                   max-size: "10m"
  #                   max-file: "3"

  #           networks:
  #             game_network:
  #               driver: bridge

  #           volumes:
  #             postgres_data:
  #           EOL
            
  #           # DB 초기화 파일 생성 (위와 동일, 필요시 프로덕션 환경에 맞게 수정)
  #           # 여기서는 개발 환경과 동일한 설정 사용
  #           cat > db_init/init.sql << 'EOL'
  #           -- PostgreSQL 유저 생성 (존재하지 않는 경우에만)
  #           DO
  #           $$
  #           BEGIN
  #              IF NOT EXISTS (
  #                 SELECT FROM pg_catalog.pg_roles
  #                 WHERE rolname = 'admin') THEN
  #                 CREATE USER admin WITH PASSWORD 'admin' SUPERUSER;
  #              END IF;
  #           END
  #           $$;

  #           -- 테이블 초기화 스크립트 (프로덕션 환경에서는 신중하게 사용)
  #           -- 기존 데이터를 유지하고 싶다면 이 부분을 주석 처리하세요
  #           DROP TABLE IF EXISTS games CASCADE;
  #           DROP TABLE IF EXISTS room_users CASCADE;
  #           DROP TABLE IF EXISTS rooms CASCADE;
  #           DROP TABLE IF EXISTS maps CASCADE;
  #           DROP TABLE IF EXISTS users CASCADE;

  #           -- 사용자 테이블
  #           CREATE TABLE users (
  #               user_id SERIAL PRIMARY KEY,
  #               user_name VARCHAR(50) NOT NULL UNIQUE,
  #               nick_name VARCHAR(16) DEFAULT 'user_' || substring(md5(random()::text), 1, 10),
  #               password_hash VARCHAR(255) NOT NULL,
  #               created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  #               last_login TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
  #           );

  #           -- 맵 테이블
  #           CREATE TABLE maps (
  #               map_id SERIAL PRIMARY KEY,
  #               map_name VARCHAR(50) NOT NULL UNIQUE
  #           );

  #           -- 방 테이블
  #           CREATE TABLE rooms (
  #               room_id SERIAL PRIMARY KEY,
  #               room_name VARCHAR(100) NOT NULL,
  #               host_id INTEGER NOT NULL REFERENCES users(user_id),
  #               ip_address VARCHAR(45),
  #               port INTEGER,
  #               max_players INTEGER NOT NULL DEFAULT 8,
  #               status VARCHAR(20) NOT NULL DEFAULT 'TERMINATED',
  #               created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  #               CHECK (status IN ('WAITING', 'GAME_IN_PROGRESS', 'TERMINATED'))
  #           );

  #           -- 방 참가자 테이블
  #           CREATE TABLE room_users (
  #               room_id SERIAL NOT NULL REFERENCES rooms(room_id),
  #               user_id INTEGER NOT NULL REFERENCES users(user_id),
  #               joined_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  #               PRIMARY KEY (room_id, user_id)
  #           );

  #           -- 게임 테이블
  #           CREATE TABLE games (
  #               game_id SERIAL PRIMARY KEY,
  #               room_id SERIAL NOT NULL REFERENCES rooms(room_id),
  #               map_id INTEGER NOT NULL REFERENCES maps(map_id),
  #               status VARCHAR(20) NOT NULL DEFAULT 'IN_PROGRESS',
  #               started_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  #               completed_at TIMESTAMP WITH TIME ZONE,
  #               CHECK (status IN ('IN_PROGRESS', 'COMPLETED'))
  #           );

  #           -- 인덱스 생성
  #           CREATE INDEX idx_users_username ON users(user_name);
  #           CREATE INDEX idx_users_nickname ON users(nick_name);
  #           CREATE INDEX idx_rooms_status ON rooms(status);
  #           CREATE INDEX idx_rooms_created_at ON rooms(created_at);
  #           CREATE INDEX idx_room_users_user_id ON room_users(user_id);
  #           CREATE INDEX idx_games_room_id ON games(room_id);
  #           CREATE INDEX idx_games_status ON games(status);

  #           -- 권한 부여
  #           GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO admin;
  #           GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO admin;

  #           ALTER DEFAULT PRIVILEGES IN SCHEMA public
  #           GRANT ALL PRIVILEGES ON TABLES TO admin;

  #           ALTER DEFAULT PRIVILEGES IN SCHEMA public
  #           GRANT ALL PRIVILEGES ON SEQUENCES TO admin;

  #           -- 초기 데이터 삽입
  #           INSERT INTO users (user_id, user_name, nick_name, password_hash)
  #           VALUES (0, 'Mirror', 'Manager', 'Mirror');

  #           INSERT INTO maps (map_name) VALUES ('SSAFY');
  #           INSERT INTO maps (map_name) VALUES ('Playground');

  #           DO $$
  #           DECLARE
  #               i INTEGER;
  #           BEGIN
  #               FOR i IN 0..19 LOOP
  #                   INSERT INTO rooms (room_name, host_id, ip_address, port)
  #                   VALUES ('room' || i, 0, '127.0.0.1', 40000 + i);
  #               END LOOP;
  #           END $$;
  #           EOL
            
  #           # GitHub Container Registry 로그인
  #           echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            
  #           # 배포 실행 (프로덕션 환경에서는 다운타임 최소화)
  #           docker-compose pull
  #           docker-compose down
  #           docker-compose up -d
            
  #           # 사용하지 않는 이미지 정리
  #           docker system prune -af
            
  #           echo "===== 프로덕션 배포 완료 ====="
  #           docker-compose ps