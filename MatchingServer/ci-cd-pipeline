#!/bin/bash

# 실패 시 스크립트 중단
set -e

# 로그 출력 기능
log() {
    echo -e "\033[1;34m[CI/CD]\033[0m \033[1;32m$(date +'%Y-%m-%d %H:%M:%S')\033[0m - $1"
}

error() {
    echo -e "\033[1;34m[CI/CD]\033[0m \033[1;31m$(date +'%Y-%m-%d %H:%M:%S')\033[0m - $1" >&2
}

# 사용법 출력
usage() {
    echo "사용법: $0 [옵션]"
    echo "옵션:"
    echo "  --init         : 초기 설정 (클론 후 최초 실행)"
    echo "  --update       : 코드 업데이트 및 재배포"
    echo "  --force-rebuild: 이미지를 완전히 새로 빌드"
    echo "  --clean        : 모든 컨테이너와 이미지 정리"
    echo "  --logs         : 서버 로그 확인"
    echo "  --help         : 도움말 출력"
    exit 1
}

# 경로 및 변수 설정
PROJECT_DIR=$(pwd)
DOCKER_COMPOSE="docker-compose"
VCPKG_HASH_FILE=".vcpkg_hash"
CODE_HASH_FILE=".code_hash"

# 도커 및 도커 컴포즈 설치 확인
check_docker_installed() {
    log "Docker 및 Docker Compose 설치 확인 중..."
    
    if ! command -v docker &> /dev/null; then
        log "Docker가 설치되어 있지 않습니다. 설치를 진행합니다..."
        chmod +x docker-install.sh
        ./docker-install.sh
    else
        log "Docker가 이미 설치되어 있습니다."
    fi

    if ! command -v docker-compose &> /dev/null; then
        log "Docker Compose가 설치되어 있지 않습니다. 설치를 진행합니다..."
        DOCKER_COMPOSE_VERSION=$(curl -s https://api.github.com/repos/docker/compose/releases/latest | grep 'tag_name' | cut -d\" -f4)
        sudo curl -L "https://github.com/docker/compose/releases/download/${DOCKER_COMPOSE_VERSION}/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
        sudo chmod +x /usr/local/bin/docker-compose
    else
        log "Docker Compose가 이미 설치되어 있습니다."
    fi

    # Docker 서비스 실행 중인지 확인
    if ! systemctl is-active --quiet docker; then
        log "Docker 서비스를 시작합니다..."
        sudo systemctl start docker
    fi
}

# 최초 설정
init_setup() {
    log "초기 설정을 시작합니다..."
    
    # 디렉토리 구조 생성
    mkdir -p db_init
    cp db-init.sql db_init/init.sql
    
    # Docker 설치 확인
    check_docker_installed
    
    # 초기 의존성 해시 저장
    if [ -f "vcpkg.json" ]; then
        sha256sum vcpkg.json > "$VCPKG_HASH_FILE"
        log "vcpkg 의존성 해시를 저장했습니다."
    fi
    
    # 초기 코드 해시 저장
    find src -type f -name "*.cpp" -o -name "*.h" -o -name "*.hpp" | sort | xargs sha256sum > "$CODE_HASH_FILE"
    log "코드 해시를 저장했습니다."
    
    # 다단계 빌드를 위한 Dockerfile 생성
    create_optimized_dockerfile
    
    # 실행
    log "컨테이너를 빌드하고 시작합니다..."
    $DOCKER_COMPOSE up -d --build
    
    log "초기 설정이 완료되었습니다!"
    log "매칭 서버가 포트 8080에서 실행 중입니다."
    log "PostgreSQL 데이터베이스가 포트 5432에서 실행 중입니다."
    $DOCKER_COMPOSE ps
}

# 코드 업데이트 및 재배포
update_deploy() {
    log "코드 업데이트 및 재배포를 시작합니다..."
    
    # Git 업데이트
    if [ -d ".git" ]; then
        log "Git 저장소에서 최신 코드를 가져옵니다..."
        git pull
    else
        log "Git 저장소가 아닙니다. 코드 변경 감지 방식으로 진행합니다."
    fi
    
    # 의존성 변경 감지
    local rebuild_deps=false
    if [ -f "vcpkg.json" ] && [ -f "$VCPKG_HASH_FILE" ]; then
        local new_hash=$(sha256sum vcpkg.json)
        local old_hash=$(cat "$VCPKG_HASH_FILE")
        
        if [ "$new_hash" != "$old_hash" ]; then
            log "vcpkg 의존성이 변경되었습니다. 전체 재빌드가 필요합니다."
            rebuild_deps=true
            sha256sum vcpkg.json > "$VCPKG_HASH_FILE"
        fi
    fi
    
    # 코드 변경 감지
    local rebuild_code=false
    local current_code_hash=$(find src -type f -name "*.cpp" -o -name "*.h" -o -name "*.hpp" | sort | xargs sha256sum)
    
    if [ -f "$CODE_HASH_FILE" ]; then
        local old_code_hash=$(cat "$CODE_HASH_FILE")
        
        if [ "$current_code_hash" != "$old_code_hash" ]; then
            log "코드가 변경되었습니다. 재빌드가 필요합니다."
            rebuild_code=true
            echo "$current_code_hash" > "$CODE_HASH_FILE"
        fi
    else
        log "이전 코드 해시 파일이 없습니다. 코드 해시를 저장하고 계속합니다."
        echo "$current_code_hash" > "$CODE_HASH_FILE"
        rebuild_code=true
    fi
    
    if [ "$rebuild_deps" = true ] || [ "$rebuild_code" = true ]; then
        log "변경 사항이 감지되었습니다. 컨테이너를 재빌드합니다..."
        
        if [ "$rebuild_deps" = true ]; then
            # 의존성이 변경된 경우 모든 이미지를 재빌드
            $DOCKER_COMPOSE down
            $DOCKER_COMPOSE build --no-cache matching_server
            $DOCKER_COMPOSE up -d
        else
            # 코드만 변경된 경우 서버 이미지만 재빌드
            $DOCKER_COMPOSE stop matching_server
            $DOCKER_COMPOSE rm -f matching_server
            $DOCKER_COMPOSE build matching_server
            $DOCKER_COMPOSE up -d matching_server
        fi
    else
        log "변경 사항이 없습니다. 재배포가 필요하지 않습니다."
    fi
    
    log "배포 상태:"
    $DOCKER_COMPOSE ps
}

# 이미지 완전히 새로 빌드
force_rebuild() {
    log "이미지를 완전히 새로 빌드합니다..."
    
    # 컨테이너 중지 및 삭제
    $DOCKER_COMPOSE down
    
    # 이미지 삭제
    local images=$(docker images -q matchingserver-matching_server)
    if [ ! -z "$images" ]; then
        docker rmi $images
    fi
    
    # 생성된 해시 파일 삭제
    rm -f "$VCPKG_HASH_FILE" "$CODE_HASH_FILE"
    
    # 다시 빌드 및 실행
    $DOCKER_COMPOSE build --no-cache
    $DOCKER_COMPOSE up -d
    
    # 새 해시 저장
    if [ -f "vcpkg.json" ]; then
        sha256sum vcpkg.json > "$VCPKG_HASH_FILE"
    fi
    find src -type f -name "*.cpp" -o -name "*.h" -o -name "*.hpp" | sort | xargs sha256sum > "$CODE_HASH_FILE"
    
    log "이미지를 새로 빌드하고 컨테이너를 시작했습니다."
    $DOCKER_COMPOSE ps
}

# 모든 컨테이너와 이미지 정리
clean_all() {
    log "모든 컨테이너와 이미지를 정리합니다..."
    
    # 컨테이너 중지 및 삭제
    $DOCKER_COMPOSE down -v
    
    # 이미지 삭제
    local images=$(docker images -q matchingserver-matching_server)
    if [ ! -z "$images" ]; then
        docker rmi $images
    fi
    
    # 사용하지 않는 볼륨, 네트워크, 이미지 정리
    docker system prune -af --volumes
    
    # 생성된 해시 파일 삭제
    rm -f "$VCPKG_HASH_FILE" "$CODE_HASH_FILE"
    
    log "모든 컨테이너와 이미지를 정리했습니다."
}

# 서버 로그 확인
show_logs() {
    log "서버 로그를 확인합니다..."
    $DOCKER_COMPOSE logs -f matching_server
}

# 최적화된 Dockerfile 생성
create_optimized_dockerfile() {
    log "최적화된 다단계 Dockerfile을 생성합니다..."
    
    cat > Dockerfile.optimized << 'EOL'
# 1단계: vcpkg 빌드 및 의존성 설치
FROM ubuntu:22.04 AS vcpkg-builder

# 기본 환경 변수 설정
ENV DEBIAN_FRONTEND=noninteractive
ENV TZ=Asia/Seoul

# vcpkg 빌드에 필요한 최소한의 패키지만 설치
RUN apt-get update && apt-get install -y \
    build-essential \
    curl \
    zip \
    unzip \
    tar \
    pkg-config \
    git \
    ninja-build \
    cmake \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

# vcpkg 설치 (소스 코드 없이)
WORKDIR /vcpkg-build
RUN git clone https://github.com/microsoft/vcpkg.git . \
    && ./bootstrap-vcpkg.sh

# vcpkg.json 파일만 복사하여 의존성 설치
COPY vcpkg.json .
RUN ./vcpkg install --triplet=x64-linux

# 2단계: 애플리케이션 빌드
FROM ubuntu:22.04 AS builder

# 기본 환경 변수 설정
ENV DEBIAN_FRONTEND=noninteractive
ENV TZ=Asia/Seoul

# 빌드에 필요한 패키지 설치
RUN apt-get update && apt-get install -y \
    build-essential \
    pkg-config \
    bison \
    flex \
    libssl-dev \
    zlib1g-dev \
    libpq-dev \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

# 작업 디렉터리 설정
WORKDIR /app

# 첫 번째 단계에서 빌드한 vcpkg와 설치된 패키지를 복사
COPY --from=vcpkg-builder /vcpkg-build /app/vcpkg
COPY --from=vcpkg-builder /vcpkg-build/vcpkg_installed /app/vcpkg_installed

# 소스 코드 복사
COPY . .

# 빌드
RUN export LD_LIBRARY_PATH="$PWD/vcpkg_installed/x64-linux/lib:$LD_LIBRARY_PATH" \
    && make

# 3단계: 실행 환경 설정
FROM ubuntu:22.04

ENV TZ=Asia/Seoul

# 실행에 필요한 최소한의 패키지만 설치
RUN apt-get update && apt-get install -y \
    libssl-dev \
    libpq-dev \
    ca-certificates \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

# 빌드된 바이너리와 필요한 라이브러리만 복사
COPY --from=builder /app/build/bin/MatchingServer /app/
COPY --from=builder /app/vcpkg_installed/x64-linux/lib /app/lib
COPY --from=builder /app/vcpkg_installed/x64-linux/bin /app/bin

# 라이브러리 경로 설정
ENV LD_LIBRARY_PATH="/app/lib:${LD_LIBRARY_PATH}"

# 서버 포트 노출
EXPOSE 8080

# 컨테이너 실행 시 서버 시작
CMD ["./MatchingServer"]
EOL
    
    # docker-compose 파일도 업데이트
    cat > docker-compose.optimized.yml << 'EOL'
version: '3.8'

services:
  db:
    image: postgres:14
    container_name: game_db
    restart: always
    environment:
      POSTGRES_USER: admin
      POSTGRES_PASSWORD: admin
      POSTGRES_DB: gamedata
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./db_init:/docker-entrypoint-initdb.d
    ports:
      - "5432:5432"
    networks:
      - game_network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U admin -d gamedata"]
      interval: 10s
      timeout: 5s
      retries: 5

  matching_server:
    build:
      context: .
      dockerfile: Dockerfile.optimized
      cache_from:
        - matchingserver-vcpkg:latest
        - matchingserver-builder:latest
    image: matchingserver:latest
    container_name: matching_server
    restart: always
    depends_on:
      db:
        condition: service_healthy
    environment:
      DB_HOST: db
      DB_PORT: 5432
      DB_NAME: gamedata
      DB_USER: admin
      DB_PASSWORD: admin
    ports:
      - "8080:8080"
    networks:
      - game_network

networks:
  game_network:
    driver: bridge

volumes:
  postgres_data:
EOL
    
    # docker-compose 파일 선택
    DOCKER_COMPOSE="docker-compose -f docker-compose.optimized.yml"
    
    log "최적화된 Dockerfile과 docker-compose 파일이 생성되었습니다."
}

# 메인 로직
main() {
    # 옵션이 없는 경우 도움말 출력
    if [ $# -eq 0 ]; then
        usage
    fi
    
    case "$1" in
        --init)
            init_setup
            ;;
        --update)
            update_deploy
            ;;
        --force-rebuild)
            force_rebuild
            ;;
        --clean)
            clean_all
            ;;
        --logs)
            show_logs
            ;;
        --help)
            usage
            ;;
        *)
            error "알 수 없는 옵션: $1"
            usage
            ;;
    esac
}

# 스크립트 실행
main "$@"