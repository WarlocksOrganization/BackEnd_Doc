#!/bin/bash

# 실패 시 스크립트 중단
set -e

# 로그 출력 기능
log() {
    echo -e "\033[1;34m[DEPLOY]\033[0m \033[1;32m$(date +'%Y-%m-%d %H:%M:%S')\033[0m - $1"
}

error() {
    echo -e "\033[1;34m[DEPLOY]\033[0m \033[1;31m$(date +'%Y-%m-%d %H:%M:%S')\033[0m - $1" >&2
}

# 사용법 출력
usage() {
    echo "사용법: $0 [옵션]"
    echo "옵션:"
    echo "  deploy         : 코드 업데이트 및 재배포"
    echo "  rollback       : 이전 버전으로 롤백"
    echo "  logs           : 서버 로그 확인"
    echo "  status         : 현재 상태 확인"
    echo "  help           : 도움말 출력"
    exit 1
}

# 경로 설정
PROJECT_DIR=$(pwd)
BACKUP_DIR="${PROJECT_DIR}/backups"
mkdir -p "${BACKUP_DIR}"

# 현재 상태를 백업
backup_current() {
    local timestamp=$(date +"%Y%m%d%H%M%S")
    local backup_file="${BACKUP_DIR}/backup_${timestamp}.tar.gz"
    
    log "현재 상태를 백업합니다: ${backup_file}"
    
    # 도커 컴포즈 설정과 현재 이미지 ID 저장
    docker compose ps -q > "${BACKUP_DIR}/container_ids_${timestamp}.txt"
    docker images -q matching-server > "${BACKUP_DIR}/image_id_${timestamp}.txt"
    
    # 소스 코드 백업 (git 제외)
    tar --exclude='.git' --exclude='node_modules' --exclude='build' --exclude='vcpkg' \
        --exclude='vcpkg_installed' -czf "${backup_file}" .
    
    log "백업 완료: ${backup_file}"
    echo "${backup_file}"
}

# 소스 코드 업데이트
update_source() {
    log "소스 코드를 업데이트합니다..."
    
    # Git 저장소인 경우
    if [ -d ".git" ]; then
        # 현재 변경사항 저장
        git stash -u
        
        # 원격 저장소에서 최신 코드 가져오기
        git fetch origin
        
        # 현재 브랜치 확인
        local current_branch=$(git rev-parse --abbrev-ref HEAD)
        
        # 최신 코드로 업데이트
        git pull origin "${current_branch}"
        
        log "Git 저장소가 ${current_branch} 브랜치로 업데이트되었습니다."
    else
        error "Git 저장소가 아닙니다. 수동으로 코드를 업데이트해주세요."
        exit 1
    fi
}

# 컨테이너 재배포
redeploy() {
    log "컨테이너를 재배포합니다..."
    
    # 백업 먼저 생성
    local backup_file=$(backup_current)
    
    # 소스 코드 업데이트
    update_source
    
    # 최적화된 Dockerfile이 없으면 생성
    if [ ! -f "Dockerfile.optimized" ]; then
        log "최적화된 Dockerfile을 생성합니다..."
        cat > Dockerfile.optimized << 'EOL'
# 1단계: vcpkg 빌드 및 의존성 설치
FROM ubuntu:22.04 AS vcpkg-builder

# 기본 환경 변수 설정
ENV DEBIAN_FRONTEND=noninteractive
ENV TZ=Asia/Seoul

# vcpkg 빌드에 필요한 최소한의 패키지만 설치
RUN apt-get update && apt-get install -y \
    build-essential \
    curl \
    zip \
    unzip \
    tar \
    pkg-config \
    git \
    ninja-build \
    cmake \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

# vcpkg 설치 (소스 코드 없이)
WORKDIR /vcpkg-build
RUN git clone https://github.com/microsoft/vcpkg.git . \
    && ./bootstrap-vcpkg.sh

# vcpkg.json 파일만 복사하여 의존성 설치
COPY vcpkg.json .
RUN ./vcpkg install --triplet=x64-linux

# 2단계: 애플리케이션 빌드
FROM ubuntu:22.04 AS builder

# 기본 환경 변수 설정
ENV DEBIAN_FRONTEND=noninteractive
ENV TZ=Asia/Seoul

# 빌드에 필요한 패키지 설치
RUN apt-get update && apt-get install -y \
    build-essential \
    pkg-config \
    bison \
    flex \
    libssl-dev \
    zlib1g-dev \
    libpq-dev \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

# 작업 디렉터리 설정
WORKDIR /app

# 첫 번째 단계에서 빌드한 vcpkg와 설치된 패키지를 복사
COPY --from=vcpkg-builder /vcpkg-build /app/vcpkg
COPY --from=vcpkg-builder /vcpkg-build/vcpkg_installed /app/vcpkg_installed

# 소스 코드 복사
COPY . .

# 빌드
RUN export LD_LIBRARY_PATH="$PWD/vcpkg_installed/x64-linux/lib:$LD_LIBRARY_PATH" \
    && make

# 3단계: 실행 환경 설정
FROM ubuntu:22.04

ENV TZ=Asia/Seoul

# 실행에 필요한 최소한의 패키지만 설치
RUN apt-get update && apt-get install -y \
    libssl-dev \
    libpq-dev \
    ca-certificates \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

# 빌드된 바이너리와 필요한 라이브러리만 복사
COPY --from=builder /app/build/bin/MatchingServer /app/
COPY --from=builder /app/vcpkg_installed/x64-linux/lib /app/lib
COPY --from=builder /app/vcpkg_installed/x64-linux/bin /app/bin

# 라이브러리 경로 설정
ENV LD_LIBRARY_PATH="/app/lib:${LD_LIBRARY_PATH}"

# 서버 포트 노출
EXPOSE 8080

# 컨테이너 실행 시 서버 시작
CMD ["./MatchingServer"]
EOL
    fi
    
    # 최적화된 docker-compose 파일이 없으면 생성
    if [ ! -f "docker-compose.optimized.yml" ]; then
        log "최적화된 docker-compose 파일을 생성합니다..."
        cat > docker-compose.optimized.yml << 'EOL'
version: '3.8'

services:
  db:
    image: postgres:14
    container_name: game_db
    restart: always
    environment:
      POSTGRES_USER: admin
      POSTGRES_PASSWORD: admin
      POSTGRES_DB: gamedata
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./db_init:/docker-entrypoint-initdb.d
    ports:
      - "5432:5432"
    networks:
      - game_network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U admin -d gamedata"]
      interval: 10s
      timeout: 5s
      retries: 5

  matching_server:
    build:
      context: .
      dockerfile: Dockerfile.optimized
      cache_from:
        - ${IMAGE_REGISTRY:-localhost}/matching-server-vcpkg:latest
        - ${IMAGE_REGISTRY:-localhost}/matching-server-builder:latest
        - ${IMAGE_REGISTRY:-localhost}/matching-server:latest
    image: ${IMAGE_REGISTRY:-localhost}/matching-server:latest
    container_name: matching_server
    restart: always
    depends_on:
      db:
        condition: service_healthy
    environment:
      DB_HOST: db
      DB_PORT: 5432
      DB_NAME: gamedata
      DB_USER: admin
      DB_PASSWORD: admin
    ports:
      - "8080:8080"
    networks:
      - game_network
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

networks:
  game_network:
    driver: bridge

volumes:
  postgres_data:
EOL
    fi
    
    # db_init 디렉토리 생성 및 SQL 스크립트 복사
    mkdir -p db_init
    cp db-init.sql db_init/init.sql
    
    # 빌드 및 재배포
    log "Docker Compose로 서버를 재배포합니다..."
    docker compose -f docker-compose.optimized.yml down
    docker compose -f docker-compose.optimized.yml build --no-cache matching_server
    docker compose -f docker-compose.optimized.yml up -d
    
    # 이전 이미지 정리
    log "사용하지 않는 이미지를 정리합니다..."
    docker image prune -f
    
    log "배포가 완료되었습니다."
    docker compose -f docker-compose.optimized.yml ps
}

# 이전 버전으로 롤백
rollback() {
    log "이전 버전으로 롤백합니다..."
    
    # 가장 최근 백업 찾기
    local latest_backup=$(ls -t "${BACKUP_DIR}"/backup_*.tar.gz | head -1)
    
    if [ -z "${latest_backup}" ]; then
        error "롤백할 백업을 찾을 수 없습니다."
        exit 1
    fi
    
    log "롤백할 백업: ${latest_backup}"
    
    # 현재 상태 백업
    backup_current
    
    # 이전 백업에서 타임스탬프 추출
    local timestamp=$(basename "${latest_backup}" | sed 's/backup_\(.*\)\.tar\.gz/\1/')
    
    # 컨테이너 중지
    log "컨테이너를 중지합니다..."
    docker compose -f docker-compose.optimized.yml down
    
    # 백업 파일 압축 해제
    log "백업 파일을 압축 해제합니다..."
    local temp_dir=$(mktemp -d)
    tar -xzf "${latest_backup}" -C "${temp_dir}"
    
    # 현재 디렉토리 내용 삭제 (중요 파일 제외)
    find . -not -path "*/\.*" -not -path "./backups*" -not -path "${temp_dir}*" -delete
    
    # 백업 파일에서 복원
    log "백업 파일에서 복원합니다..."
    cp -r "${temp_dir}"/* .
    
    # 임시 디렉토리 삭제
    rm -rf "${temp_dir}"
    
    # 컨테이너 재시작
    log "컨테이너를 재시작합니다..."
    docker compose -f docker-compose.optimized.yml up -d
    
    log "롤백이 완료되었습니다."
    docker compose -f docker-compose.optimized.yml ps
}

# 로그 확인
show_logs() {
    log "매칭 서버 로그를 확인합니다..."
    docker compose -f docker-compose.optimized.yml logs -f matching_server
}

# 상태 확인
check_status() {
    log "서버 상태를 확인합니다..."
    docker compose -f docker-compose.optimized.yml ps
    
    log "리소스 사용량:"
    docker stats --no-stream matching_server game_db
}

# 메인 로직
main() {
    # 옵션이 없는 경우 도움말 출력
    if [ $# -eq 0 ]; then
        usage
    fi
    
    case "$1" in
        deploy)
            redeploy
            ;;
        rollback)
            rollback
            ;;
        logs)
            show_logs
            ;;
        status)
            check_status
            ;;
        help)
            usage
            ;;
        *)
            error "알 수 없는 옵션: $1"
            usage
            ;;
    esac
}

# 스크립트 실행
main "$@"